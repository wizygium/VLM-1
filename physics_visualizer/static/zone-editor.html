<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handball Zone Editor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 320px;
            background: #16213e;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid #333;
        }
        .sidebar-header h1 {
            font-size: 1.2rem;
            color: #667eea;
            margin-bottom: 8px;
        }
        .instructions {
            font-size: 12px;
            color: #999;
            line-height: 1.6;
        }
        .instructions kbd {
            background: #2a2a4a;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 1px 5px;
            font-size: 11px;
            color: #ccc;
        }

        /* --- Toolbar --- */
        .toolbar {
            display: flex;
            gap: 6px;
            padding: 10px 15px;
            border-bottom: 1px solid #333;
            flex-wrap: wrap;
        }
        .toolbar button {
            padding: 6px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a4a;
            color: #ddd;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s;
        }
        .toolbar button:hover { background: #3a3a5a; }
        .toolbar button.active { background: #667eea; border-color: #667eea; color: #fff; }
        .toolbar button.danger { border-color: #c0392b; color: #e74c3c; }
        .toolbar button.danger:hover { background: #c0392b; color: #fff; }
        .toolbar label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #aaa;
            cursor: pointer;
        }
        .toolbar label input[type="checkbox"] { accent-color: #667eea; }

        /* --- Zone List --- */
        .zone-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .zone-section h3 {
            font-size: 0.85rem;
            color: #888;
            padding: 8px 15px;
            border-bottom: 1px solid #333;
        }
        .zone-list {
            flex: 1;
            overflow-y: auto;
            padding: 4px 0;
        }
        .zone-item {
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: all 0.15s;
        }
        .zone-item:hover { background: rgba(102, 126, 234, 0.1); }
        .zone-item.selected {
            background: rgba(102, 126, 234, 0.15);
            border-left-color: #667eea;
        }
        .zone-swatch {
            width: 18px;
            height: 18px;
            border-radius: 3px;
            border: 1px solid rgba(255,255,255,0.2);
            flex-shrink: 0;
        }
        .zone-label-group {
            flex: 1;
            min-width: 0;
        }
        .zone-label-group input {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 1px solid transparent;
            color: #e0e0e0;
            font-size: 13px;
            padding: 2px 0;
            outline: none;
        }
        .zone-label-group input:hover { border-bottom-color: #555; }
        .zone-label-group input:focus { border-bottom-color: #667eea; }
        .zone-meta {
            font-size: 10px;
            color: #666;
        }
        .zone-delete {
            background: transparent;
            border: 1px solid transparent;
            color: #666;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
            border-radius: 3px;
            transition: all 0.15s;
        }
        .zone-delete:hover { color: #e74c3c; border-color: #e74c3c; }

        /* --- Export --- */
        .export-section {
            border-top: 1px solid #333;
            padding: 10px 15px;
        }
        .export-section button {
            padding: 6px 14px;
            border: 1px solid #667eea;
            border-radius: 4px;
            background: transparent;
            color: #667eea;
            cursor: pointer;
            font-size: 12px;
            margin-bottom: 6px;
        }
        .export-section button:hover { background: #667eea; color: #fff; }
        .export-section textarea {
            width: 100%;
            height: 100px;
            background: #0d0d1a;
            color: #0f0;
            border: 1px solid #333;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 10px;
            padding: 6px;
            resize: vertical;
        }

        /* --- Status Bar --- */
        .status-bar {
            padding: 6px 15px;
            background: #0d0d1a;
            font-size: 11px;
            color: #888;
            border-top: 1px solid #333;
        }

        /* --- Canvas Area --- */
        .canvas-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #111;
            padding: 20px;
        }
        canvas {
            cursor: crosshair;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>Zone Editor</h1>
            <div class="instructions">
                <strong>Click</strong> to place vertices on the court.<br>
                <strong>Click near start point</strong> or <strong>double-click</strong> to close polygon.<br>
                <kbd>Esc</kbd> cancel &nbsp; <kbd>Ctrl+Z</kbd> undo point &nbsp; <kbd>Del</kbd> delete zone
            </div>
        </div>

        <div class="toolbar">
            <button id="btn-draw" class="active" onclick="setMode('draw')">Draw</button>
            <button onclick="undoLastPoint()">Undo Pt</button>
            <button onclick="undoLastZone()">Undo Zone</button>
            <button class="danger" onclick="clearAll()">Clear All</button>
            <label><input type="checkbox" id="snap-toggle" checked> Snap 0.5m</label>
        </div>

        <div class="zone-section">
            <h3>Zones (<span id="zone-count">0</span>)</h3>
            <div class="zone-list" id="zone-list">
                <div style="padding: 20px; color: #555; font-size: 13px; text-align: center;">
                    No zones yet. Click on the court to start drawing.
                </div>
            </div>
        </div>

        <div class="export-section">
            <button onclick="exportJSON()">Export JSON</button>
            <button onclick="copyJSON()">Copy</button>
            <textarea id="export-output" readonly placeholder="Click Export to generate zone definitions..."></textarea>
        </div>

        <div class="status-bar" id="status">Ready</div>
    </div>

    <div class="canvas-area">
        <canvas id="court-canvas"></canvas>
    </div>

    <script>
    // ============================================================
    // Configuration
    // ============================================================
    const COURT_W = 20;   // meters wide
    const COURT_D = 20;   // meters deep (half-court)
    const GOAL_W  = 3;    // meters
    const MARGIN  = 45;   // pixels around the court

    const ZONE_COLORS = [
        'rgba(231, 76, 60, 0.3)',   'rgba(52, 152, 219, 0.3)',
        'rgba(46, 204, 113, 0.3)',  'rgba(241, 196, 15, 0.3)',
        'rgba(155, 89, 182, 0.3)',  'rgba(230, 126, 34, 0.3)',
        'rgba(26, 188, 156, 0.3)',  'rgba(192, 57, 43, 0.3)',
        'rgba(41, 128, 185, 0.3)',  'rgba(39, 174, 96, 0.3)',
        'rgba(243, 156, 18, 0.3)',  'rgba(142, 68, 173, 0.3)',
        'rgba(211, 84, 0, 0.3)',    'rgba(22, 160, 133, 0.3)',
        'rgba(52, 73, 94, 0.3)',    'rgba(236, 240, 241, 0.3)',
    ];
    const ZONE_BORDERS = [
        'rgba(231, 76, 60, 0.85)',  'rgba(52, 152, 219, 0.85)',
        'rgba(46, 204, 113, 0.85)', 'rgba(241, 196, 15, 0.85)',
        'rgba(155, 89, 182, 0.85)', 'rgba(230, 126, 34, 0.85)',
        'rgba(26, 188, 156, 0.85)', 'rgba(192, 57, 43, 0.85)',
        'rgba(41, 128, 185, 0.85)', 'rgba(39, 174, 96, 0.85)',
        'rgba(243, 156, 18, 0.85)', 'rgba(142, 68, 173, 0.85)',
        'rgba(211, 84, 0, 0.85)',   'rgba(22, 160, 133, 0.85)',
        'rgba(52, 73, 94, 0.85)',   'rgba(236, 240, 241, 0.85)',
    ];

    // ============================================================
    // State
    // ============================================================
    let zones = [];          // {points:[{x,y}], label, color, border}
    let currentPts = [];     // points of polygon being drawn
    let selectedIdx = -1;
    let colorIdx = 0;
    let mouseM = null;       // mouse in meters
    let mousePx = null;      // mouse in pixels
    let snapEnabled = true;

    // ============================================================
    // Canvas Setup
    // ============================================================
    const canvas = document.getElementById('court-canvas');
    const ctx = canvas.getContext('2d');

    function fitCanvas() {
        const area = document.querySelector('.canvas-area');
        const maxW = area.clientWidth - 40;
        const maxH = area.clientHeight - 40;
        const size = Math.min(maxW, maxH, 800);
        canvas.width = size;
        canvas.height = size;
        render();
    }
    window.addEventListener('resize', fitCanvas);

    // Coordinate helpers
    function courtPx() { return canvas.width - MARGIN * 2; }
    function ppm() { return courtPx() / COURT_W; } // pixels per meter

    function m2px(mx, my) {
        const s = ppm();
        return { x: MARGIN + mx * s, y: MARGIN + (COURT_D - my) * s };
    }
    function px2m(px, py) {
        const s = ppm();
        return { x: (px - MARGIN) / s, y: COURT_D - (py - MARGIN) / s };
    }
    function snap(mx, my) {
        if (!snapEnabled) return { x: mx, y: my };
        return { x: Math.round(mx * 2) / 2, y: Math.round(my * 2) / 2 };
    }

    // ============================================================
    // Court Drawing
    // ============================================================
    function drawCourt() {
        const W = canvas.width, H = canvas.height;
        const cp = courtPx(), s = ppm();

        // Background
        ctx.fillStyle = '#1a2a1a';
        ctx.fillRect(0, 0, W, H);

        // Court surface
        ctx.fillStyle = '#2d5a2d';
        ctx.fillRect(MARGIN, MARGIN, cp, cp);

        // Grid (every meter, faint)
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        for (let m = 0; m <= COURT_W; m++) {
            const p = m2px(m, 0);
            ctx.beginPath(); ctx.moveTo(p.x, MARGIN); ctx.lineTo(p.x, MARGIN + cp); ctx.stroke();
            const p2 = m2px(0, m);
            ctx.beginPath(); ctx.moveTo(MARGIN, p2.y); ctx.lineTo(MARGIN + cp, p2.y); ctx.stroke();
        }

        // Meter labels
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let m = 0; m <= COURT_W; m += 2) {
            const p = m2px(m, 0);
            ctx.fillText(`${m}`, p.x, MARGIN + cp + 4);
        }
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let m = 0; m <= COURT_D; m += 2) {
            const p = m2px(0, m);
            ctx.fillText(`${m}`, MARGIN - 5, p.y);
        }

        // Court lines
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;

        // Court border
        ctx.strokeRect(MARGIN, MARGIN, cp, cp);

        // Goal line (bottom) - already part of border but emphasize
        // Goal (3m wide)
        const cx = COURT_W / 2, gh = GOAL_W / 2;
        const gL = m2px(cx - gh, 0), gR = m2px(cx + gh, 0);
        ctx.fillStyle = '#fff';
        ctx.fillRect(gL.x, gL.y - 2, gR.x - gL.x, 6);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.strokeRect(gL.x, gL.y - 2, gR.x - gL.x, 6);

        // D-lines
        const leftPost  = { x: cx - gh, y: 0 };
        const rightPost = { x: cx + gh, y: 0 };

        // 6m D-line (solid)
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        drawDLine(leftPost, rightPost, 6);

        // 9m D-line (dashed)
        ctx.setLineDash([8, 6]);
        drawDLine(leftPost, rightPost, 9);
        ctx.setLineDash([]);

        // 7m penalty mark
        const p7 = m2px(cx, 7);
        ctx.fillStyle = '#fff';
        ctx.fillRect(p7.x - 8, p7.y - 1, 16, 2);

        // Label key distances
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const p6label = m2px(cx + gh + 0.3, 6);
        ctx.fillText('6m', p6label.x, p6label.y);
        const p9label = m2px(cx + gh + 0.3, 9);
        ctx.fillText('9m', p9label.x, p9label.y);
    }

    function drawDLine(leftPost, rightPost, radius) {
        const steps = 80;

        // Left arc: center at leftPost, from angle π to π/2
        ctx.beginPath();
        let started = false;
        for (let i = 0; i <= steps; i++) {
            const a = Math.PI - (i / steps) * (Math.PI / 2);
            const mx = leftPost.x + radius * Math.cos(a);
            const my = leftPost.y + radius * Math.sin(a);
            if (mx < 0 || mx > COURT_W) continue;
            const p = m2px(mx, my);
            if (!started) { ctx.moveTo(p.x, p.y); started = true; }
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // Connecting straight line at top
        const tL = m2px(leftPost.x, radius);
        const tR = m2px(rightPost.x, radius);
        ctx.beginPath(); ctx.moveTo(tL.x, tL.y); ctx.lineTo(tR.x, tR.y); ctx.stroke();

        // Right arc: center at rightPost, from π/2 to 0
        ctx.beginPath();
        started = false;
        for (let i = 0; i <= steps; i++) {
            const a = Math.PI / 2 - (i / steps) * (Math.PI / 2);
            const mx = rightPost.x + radius * Math.cos(a);
            const my = rightPost.y + radius * Math.sin(a);
            if (mx < 0 || mx > COURT_W) continue;
            const p = m2px(mx, my);
            if (!started) { ctx.moveTo(p.x, p.y); started = true; }
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }

    // ============================================================
    // Zone Drawing
    // ============================================================
    function drawZones() {
        zones.forEach((z, i) => {
            if (z.points.length < 3) return;
            const sel = (i === selectedIdx);

            // Fill
            ctx.fillStyle = z.color;
            ctx.beginPath();
            const p0 = m2px(z.points[0].x, z.points[0].y);
            ctx.moveTo(p0.x, p0.y);
            for (let j = 1; j < z.points.length; j++) {
                const p = m2px(z.points[j].x, z.points[j].y);
                ctx.lineTo(p.x, p.y);
            }
            ctx.closePath();
            ctx.fill();

            // Border
            ctx.strokeStyle = sel ? '#fff' : z.border;
            ctx.lineWidth = sel ? 3 : 1.5;
            ctx.stroke();

            // Vertices
            z.points.forEach(pt => {
                const p = m2px(pt.x, pt.y);
                ctx.fillStyle = sel ? '#fff' : 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.arc(p.x, p.y, sel ? 4 : 2.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Label at centroid
            if (z.label) {
                const c = centroid(z.points);
                const cp = m2px(c.x, c.y);
                ctx.font = 'bold 13px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const tw = ctx.measureText(z.label).width;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                const pad = 4;
                ctx.fillRect(cp.x - tw/2 - pad, cp.y - 8 - pad/2, tw + pad*2, 16 + pad);
                ctx.fillStyle = '#fff';
                ctx.fillText(z.label, cp.x, cp.y);
            }
        });
    }

    function centroid(pts) {
        let sx = 0, sy = 0;
        pts.forEach(p => { sx += p.x; sy += p.y; });
        return { x: sx / pts.length, y: sy / pts.length };
    }

    // ============================================================
    // Current Polygon Drawing
    // ============================================================
    function drawCurrentPolygon() {
        if (currentPts.length === 0 && !mouseM) return;

        // Lines between placed points
        if (currentPts.length > 0) {
            ctx.strokeStyle = '#ffeb3b';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);

            ctx.beginPath();
            const p0 = m2px(currentPts[0].x, currentPts[0].y);
            ctx.moveTo(p0.x, p0.y);
            for (let i = 1; i < currentPts.length; i++) {
                const p = m2px(currentPts[i].x, currentPts[i].y);
                ctx.lineTo(p.x, p.y);
            }
            // Rubber-band line to mouse
            if (mouseM) {
                const sm = snap(mouseM.x, mouseM.y);
                const mp = m2px(sm.x, sm.y);
                ctx.lineTo(mp.x, mp.y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Vertices
            currentPts.forEach((pt, i) => {
                const p = m2px(pt.x, pt.y);
                ctx.beginPath();
                ctx.arc(p.x, p.y, i === 0 ? 7 : 5, 0, Math.PI * 2);
                ctx.fillStyle = i === 0 ? '#4caf50' : '#ffeb3b';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Close hint: highlight start point if mouse is near
            if (mouseM && currentPts.length >= 3) {
                const sm = snap(mouseM.x, mouseM.y);
                const d = Math.hypot(sm.x - currentPts[0].x, sm.y - currentPts[0].y);
                if (d < 0.8) {
                    const fp = m2px(currentPts[0].x, currentPts[0].y);
                    ctx.beginPath();
                    ctx.arc(fp.x, fp.y, 12, 0, Math.PI * 2);
                    ctx.strokeStyle = '#4caf50';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        // Cursor crosshair + coords
        if (mouseM && mousePx) {
            const sm = snap(mouseM.x, mouseM.y);
            const sp = m2px(sm.x, sm.y);

            // Snap indicator
            if (snapEnabled) {
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,235,59,0.7)';
                ctx.fill();
            }

            // Coordinate label
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.font = '11px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ctx.fillText(`(${sm.x.toFixed(1)}, ${sm.y.toFixed(1)})`, mousePx.x + 14, mousePx.y - 6);
        }
    }

    // ============================================================
    // Full Render
    // ============================================================
    function render() {
        drawCourt();
        drawZones();
        drawCurrentPolygon();
    }

    // ============================================================
    // Event Handling
    // ============================================================
    canvas.addEventListener('click', (e) => {
        const r = canvas.getBoundingClientRect();
        const px = e.clientX - r.left;
        const py = e.clientY - r.top;
        const m = px2m(px, py);

        // Ignore clicks outside court area
        if (m.x < -0.5 || m.x > COURT_W + 0.5 || m.y < -0.5 || m.y > COURT_D + 0.5) return;

        const sm = snap(m.x, m.y);

        // Check if clicking near first point to close polygon
        if (currentPts.length >= 3) {
            const d = Math.hypot(sm.x - currentPts[0].x, sm.y - currentPts[0].y);
            if (d < 0.8) {
                closePolygon();
                return;
            }
        }

        currentPts.push({ x: sm.x, y: sm.y });
        setStatus(`Vertex ${currentPts.length} at (${sm.x.toFixed(1)}, ${sm.y.toFixed(1)})m — click near green dot to close`);
        render();
    });

    canvas.addEventListener('dblclick', (e) => {
        if (currentPts.length >= 4) {
            // Remove extra point added by the second click of double-click
            currentPts.pop();
            closePolygon();
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        const r = canvas.getBoundingClientRect();
        mousePx = { x: e.clientX - r.left, y: e.clientY - r.top };
        mouseM = px2m(mousePx.x, mousePx.y);
        render();
    });

    canvas.addEventListener('mouseleave', () => {
        mouseM = null;
        mousePx = null;
        render();
    });

    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        if (e.key === 'Escape') {
            currentPts = [];
            setStatus('Cancelled current polygon.');
            render();
        }
        if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            undoLastPoint();
        }
        if (e.key === 'Delete' || e.key === 'Backspace') {
            e.preventDefault();
            deleteSelected();
        }
    });

    document.getElementById('snap-toggle').addEventListener('change', (e) => {
        snapEnabled = e.target.checked;
    });

    // ============================================================
    // Actions
    // ============================================================
    function closePolygon() {
        const ci = colorIdx % ZONE_COLORS.length;
        const label = `Zone ${zones.length + 1}`;

        zones.push({
            points: [...currentPts],
            label: label,
            color: ZONE_COLORS[ci],
            border: ZONE_BORDERS[ci]
        });
        colorIdx++;
        currentPts = [];
        selectedIdx = zones.length - 1;

        updateZoneList();
        render();
        setStatus(`"${label}" created — rename it in the sidebar`);

        // Auto-focus the new label input
        setTimeout(() => {
            const inputs = document.querySelectorAll('.zone-label-group input');
            const last = inputs[inputs.length - 1];
            if (last) { last.focus(); last.select(); }
        }, 50);
    }

    function setMode(m) {
        document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-draw').classList.add('active');
        currentPts = [];
        render();
    }

    function undoLastPoint() {
        if (currentPts.length > 0) {
            currentPts.pop();
            setStatus(`Removed last point. ${currentPts.length} remaining.`);
            render();
        }
    }

    function undoLastZone() {
        if (zones.length > 0) {
            const removed = zones.pop();
            if (selectedIdx >= zones.length) selectedIdx = zones.length - 1;
            updateZoneList();
            render();
            setStatus(`Removed "${removed.label}".`);
        }
    }

    function deleteSelected() {
        if (selectedIdx >= 0 && selectedIdx < zones.length) {
            const name = zones[selectedIdx].label;
            zones.splice(selectedIdx, 1);
            selectedIdx = Math.min(selectedIdx, zones.length - 1);
            updateZoneList();
            render();
            setStatus(`Deleted "${name}".`);
        }
    }

    function clearAll() {
        if (zones.length === 0 && currentPts.length === 0) return;
        if (!confirm('Clear all zones?')) return;
        zones = [];
        currentPts = [];
        selectedIdx = -1;
        colorIdx = 0;
        updateZoneList();
        render();
        setStatus('All zones cleared.');
    }

    // ============================================================
    // Zone List UI
    // ============================================================
    function updateZoneList() {
        const list = document.getElementById('zone-list');
        document.getElementById('zone-count').textContent = zones.length;

        if (zones.length === 0) {
            list.innerHTML = '<div style="padding:20px;color:#555;font-size:13px;text-align:center;">No zones yet. Click on the court to start drawing.</div>';
            return;
        }

        list.innerHTML = '';
        zones.forEach((z, i) => {
            const item = document.createElement('div');
            item.className = `zone-item ${i === selectedIdx ? 'selected' : ''}`;
            item.onclick = (e) => {
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
                    selectedIdx = i;
                    updateZoneList();
                    render();
                }
            };

            // Color swatch
            const swatch = document.createElement('div');
            swatch.className = 'zone-swatch';
            swatch.style.background = z.color.replace('0.3', '0.6');

            // Label input + meta
            const labelGroup = document.createElement('div');
            labelGroup.className = 'zone-label-group';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = z.label;
            input.oninput = () => { z.label = input.value; render(); };
            input.onfocus = () => { selectedIdx = i; updateZoneList(); render(); };

            const meta = document.createElement('div');
            meta.className = 'zone-meta';
            const c = centroid(z.points);
            meta.textContent = `${z.points.length} pts — center (${c.x.toFixed(1)}, ${c.y.toFixed(1)})`;

            labelGroup.appendChild(input);
            labelGroup.appendChild(meta);

            // Delete button
            const del = document.createElement('button');
            del.className = 'zone-delete';
            del.textContent = '\u2715';
            del.title = 'Delete zone';
            del.onclick = (e) => {
                e.stopPropagation();
                zones.splice(i, 1);
                if (selectedIdx >= zones.length) selectedIdx = zones.length - 1;
                updateZoneList();
                render();
            };

            item.appendChild(swatch);
            item.appendChild(labelGroup);
            item.appendChild(del);
            list.appendChild(item);
        });
    }

    // ============================================================
    // Export
    // ============================================================
    function exportJSON() {
        const out = zones.map(z => ({
            label: z.label,
            vertices: z.points.map(p => [
                Math.round(p.x * 10) / 10,
                Math.round(p.y * 10) / 10
            ]),
            centroid: (() => {
                const c = centroid(z.points);
                return [Math.round(c.x * 10) / 10, Math.round(c.y * 10) / 10];
            })()
        }));
        document.getElementById('export-output').value = JSON.stringify(out, null, 2);
    }

    function copyJSON() {
        exportJSON();
        const ta = document.getElementById('export-output');
        ta.select();
        navigator.clipboard.writeText(ta.value).then(() => setStatus('JSON copied to clipboard.'));
    }

    function setStatus(msg) {
        document.getElementById('status').textContent = msg;
    }

    // ============================================================
    // Init
    // ============================================================
    fitCanvas();
    </script>
</body>
</html>
